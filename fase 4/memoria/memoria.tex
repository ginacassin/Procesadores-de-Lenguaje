% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{amsmath}
\usepackage{titling}
\usepackage{array}
\usepackage{longtable}
\usepackage{graphicx}
\graphicspath{ {/} }

% Titles
\title{Memoria: Procesadores de Lenguaje - Lenguaje Tiny}
\author{Burgos Sosa, Rodrigo \and Cassin, Gina Andrea \and Estebán Velasco, Luis \and Rabbia, Santiago Elias}
\date{Curso 2024}

% Document
\setcounter{section}{-1}
\begin{document}
\begin{titlepage}
    \centering
    {\Huge Memoria: Procesadores de Lenguaje - Lenguaje Tiny \par}
    \vspace{1cm}
    {\Large Fase 4: Finalización del procesador para Tiny \par}
    \vspace{2cm}
    {\Large Grupo G03: \par}
    {\Large Burgos Sosa Rodrigo, Cassin Gina Andrea, \par}
    {\Large Estebán Velasco Luis, Rabbia Santiago Elias \par}
    \vspace{2cm}
    {\Large Curso 2024 \par}
\end{titlepage}
\thispagestyle{empty}

    \newpage

    \section{Introducción}
        En el siguiente documento se expondrá una memoria sobre las especificaciones necesarias para finalizar la implementación del procesador de lenguaje Tiny.         
        Se realizará:
        \begin{enumerate}
            \item Una especificación del procesamiento de vinculación.
            \item Una especificación del procesamiento de comprobación de tipos.
            \item Una especificación del procesamiento de asignación de espacio.
            \item Una descripción del repertorio de instrucciones de la máquina-p necesario para soportar la traducción de Tiny a código-p.
            \item Una especificación del procesamiento de etiquetado.
            \item Una especificación del procesamiento de generación de código.
        \end{enumerate}

    \section{Especificación del procesamiento de vinculación}
        A continuación se presentará la especificación del procesamiento de vinculación. Durante este procesamiento se comprueban las reglas de ámbito del lenguaje, siendo estas dos:
        
        \begin{itemize}
            \item Se comprueba que, cuando se utiliza un identificador, éste haya sido previamente declarado.
            \item Los usos de los identificadores se vinculan con sus declaraciones.
        \end{itemize}
        Cada nodo de tipo iden tendrá un atributo vinculo: una referencia a nodos de
        tipo Dec.

        \subsection{Tabla de símbolos}
            Es un diccionario String $\rightarrow$ Dec, con las siguientes operaciones:
            \begin{itemize}
                \item \textbf{creaTS()}: Crea una tabla de símbolos vacía que no tiene aún ningún ámbito abierto.
                \item \textbf{abreAmbito(ts)}: Añade a la tabla de símbolos ts un nuevo ámbito, que tendrá como padre el ámbito más reciente (o $\bot$, si aún no se ha creado ningún ámbito).
                \item \textbf{contiene(ts,id)}: Comprueba si la tabla de símbolos ts contiene ya una entrada para el identificador id.
                \item \textbf{inserta(ts,id,dec)}: Inserta el identificador id en la tabla de símbolos ts, con la referencia al nodo dec como valor.
                \item \textbf{vinculoDe(ts,id)}: Recupera la referencia asociada a id en la tabla de símbolos ts. Para ello busca sucesivamente en la cadena de ámbitos, hasta que lo encuentra. Si no está, devuelve $\bot$.
                \item \textbf{cierraAmbito(ts)}: Fija en ts el ámbito actual al ámbito padre del ámbito más reciente.
            \end{itemize}

        \subsection{Organización del procesamiento}
            \begin{itemize}
                \item Procesar, en orden de aparición, las declaraciones en la sección de declaraciones.
                \item Para cada declaración:
                    \begin{itemize}
                        \item Se comprueba que el identificador no esté en la tabla de símbolos (si es así, se señala error).
                        \item Vincular los identificadores en la expresión.
                        \item Asociar la declaración con el identificador en la tabla de símbolos.
                    \end{itemize}
                \item La vinculación en las expresiones compuestas se lleva a cabo vinculando en cada uno de sus operandos.
                \item La vinculación de las expresiones iden se lleva a cabo:
                    \begin{itemize}
                        \item Comprobando que el identificador esté en la tabla de símbolos. Si no es así, se señala error.
                        \item Fijando el atributo vinculo al nodo asociado al identificador en la tabla de símbolos.
                    \end{itemize}
                \item Para permitir el algoritmo de compatibilidad estructural de tipos recursivos, se realizan dos pasadas en el vinculador en la sección de declaraciones.
            \end{itemize}

        \subsection{Vinculador para Tiny}
            \begin{itemize}
                \item var ts \/// \textit{La tabla de símbolos}
                \item vincula(prog(Bloq)):
                    \subitem ts = creaTS()
                    \subitem vincula(Bloq)       
                \item vincula(bloq(Decs, Insts)):
                    \subitem abreAmbito(ts)
                    \subitem vincula(Decs)
                    \subitem vincula(Insts)
                    \subitem cierraAmbito(ts)
                \item vincula(si\_decs(DecsAux)):
                    \subitem vincula1(DecsAux)
                    \subitem vincula2(DecsAux)
                \item vincula(no\_decs()):
                    \subitem noop
            \end{itemize}
            \textbf{\/// Primera pasada}
            \begin{itemize}
                \item vincula1(muchas\_decs(DecsAux, Dec)):
                    \subitem vincula1(DecsAux)
                    \subitem vincula1(Dec)
                \item vincula1(una\_dec(Dec)):
                    \subitem vincula1(Dec)
                \item vincula1(dec\_var(T, string)):
                    \subitem vincula1(T)
                    \subitem if contiene(ts, string) then
                        \subsubitem error
                    \subitem else
                        \subsubitem inserta(ts, string, \$)
                    \subitem end if 
                \item vincula1(dec\_tipo(T, string)):
                    \subitem vincula1(T)
                    \subitem if contiene(ts, string) then
                        \subsubitem error
                    \subitem else
                        \subsubitem inserta(ts, string, \$)
                    \subitem end if
                \item vincula1(dec\_proc(string, ParamsF, Bloq)):
                    \subitem if contiene(ts, string) then
                        \subsubitem error
                    \subitem else
                        \subsubitem inserta(ts, string, \$)
                    \subitem end if
                    \subitem abreAmbito(ts)
                    \subitem vincula1(ParamsF)
                    \subitem vincula2(ParamsF)
                    \subitem vincula(Bloq)
                    \subitem cierraAmbito(ts)
                \item vincula1(si\_paramF(ParamsFL)):
                    \subitem vincula1(ParamsFL)
                \item vincula1(no\_paramF()):
                    \subitem noop
                \item vincula1(muchos\_paramsF(ParamsFL, Param)):
                    \subitem vincula1(ParamsFL)
                    \subitem vincula1(Param)
                \item vincula1(un\_paramF(Param)): 
                    \subitem vincula1(Param) 
                \item vincula1(param\_ref(T, string)): 
                    \subitem vincula1(T) 
                    \subitem if contiene(ts, string) then 
                        \subsubitem error 
                    \subitem else 
                        \subsubitem inserta(ts, string, \$) 
                    \subitem end if
                \item vincula1(param(T, string)): 
                    \subitem vincula1(T) 
                    \subitem if contiene(ts, string) then 
                        \subsubitem error 
                    \subitem else 
                        \subsubitem inserta(ts, string, \$) 
                    \subitem end if
                \item vincula1(tipo\_array(T, tam)): 
                    \subitem vincula1(T) 
                    \subitem if tam $<$ 0 then \/// \textit{Pre-tipado: El tamaño de los tipos array es siempre un entero no negativo}
                        \subsubitem error 
                    \subitem end if
                \item vincula1(tipo\_punt(T)): 
                    \subitem if T $\neq$ tipo\_iden(\_) then 
                        \subsubitem vincula1(T)
                    \subitem end if
                \item vincula1(tipo\_struct(LCampos)): 
                    \subitem abreAmbito(ts)  \/// \textit{Pre-tipado: Las definiciones de tipos registro no tienen campos duplicados}
                    \subitem vincula1(LCampos)
                    \subitem cierraAmbito(ts)
                \item vincula1(muchos\_campos(LCampos, Campo)): 
                    \subitem vincula1(LCampos) 
                    \subitem vincula1(Campo)
                \item vincula1(un\_campo(Campo)): 
                    \subitem vincula1(Campo)
                \item vincula1(campo(T, string)): 
                    \subitem vincula1(T)
                    \subitem if contiene(ts, string) then
                        \subsubitem error
                    \subitem else
                        \subsubitem inserta(ts, string, \$)
                    \subitem end if
                \item vincula1(tipo\_int()): 
                    \subitem noop 
                \item vincula1(tipo\_real()): 
                    \subitem noop
                \item vincula1(tipo\_bool()): 
                    \subitem noop
                \item vincula1(tipo\_string()): 
                    \subitem noop
                \item vincula1(tipo\_iden(string)):  \/// \textit{Pre-tipado: Los vínculos de los nombres de tipo utilizados en las declaraciones de tipo deben ser declaraciones type}                   \subitem \$.vinculo = vinculoDe(ts,string)
                    \subitem if \$.vinculo $\neq$ dec\_tipo(\_,\_) then
                        \subsubitem error
                    \subitem end if
            \end{itemize}
            \textbf{\/// Segunda pasada}
            \begin{itemize}
                \item vincula2(muchas\_decs(DecsAux, Dec)):
                    \subitem vincula2(DecsAux)
                    \subitem vincula2(Dec)
                \item vincula2(una\_dec(Dec)):
                    \subitem vincula2(Dec)
                \item vincula2(dec\_var(T, string)):
                    \subitem vincula2(T)
                \item vincula2(dec\_tipo(T, string)):
                    \subitem vincula2(T)
                \item vincula2(dec\_proc(string, ParamsF, Bloq)):
                    \subitem noop
                \item vincula2(si\_paramF(ParamsFL)):
                    \subitem vincula2(ParamsFL)
                \item vincula2(no\_paramF()):
                    \subitem noop
                \item vincula2(muchos\_paramsF(ParamsFL, Param)):
                    \subitem vincula2(ParamsFL)
                    \subitem vincula2(Param)
                \item vincula2(un\_paramF(Param)): 
                    \subitem vincula2(Param) 
                \item vincula2(param\_ref(T, string)): 
                    \subitem vincula2(T) 
                \item vincula2(param(T, string)): 
                    \subitem vincula2(T)
                \item vincula2(tipo\_array(T, string)): 
                    \subitem vincula2(T)
                \item vincula2(tipo\_punt(T)): 
                    \subitem if T = tipo\_iden(iden) then 
                        \subsubitem T.vinculo = vinculoDe(ts,iden)
                        \subsubitem if T.vinculo $\neq$ dec\_tipo(\_,\_) then
                            \subsubitem \hspace{2em} error
                        \subsubitem end if
                    \subitem else
                        \subsubitem vincula2(T)
                    \subitem end if
                \item vincula2(tipo\_struct(LCampos)): 
                    \subitem vincula2(LCampos)
                \item vincula2(muchos\_campos(LCampos, Campo)): 
                    \subitem vincula2(LCampos) 
                    \subitem vincula2(Campo)
                \item vincula2(un\_campo(Campo)): 
                    \subitem vincula2(Campo)
                \item vincula2(campo(T, string)): 
                    \subitem vincula2(T)
                \item vincula1(tipo\_int()): 
                    \subitem noop 
                \item vincula1(tipo\_real()): 
                    \subitem noop
                \item vincula1(tipo\_bool()): 
                    \subitem noop
                \item vincula1(tipo\_string()): 
                    \subitem noop
                \item vincula1(tipo\_iden(string)): 
                    \subitem noop
            \end{itemize}
            \textbf{\/// Única pasada}
            \begin{itemize}
                \item vincula(si\_instr(InstAux)): 
                    \subitem vincula(InstAux)
                \item vincula(no\_instr()): 
                    \subitem noop
                \item vincula(muchas\_instr(InstsAux, Inst): 
                    \subitem vincula(InstsAux) 
                    \subitem vincula(Inst)
                \item vincula(una\_instr(Inst)): 
                    \subitem vincula(Inst)
                \item vincula(instr\_expr(Exp)): 
                    \subitem vincula(Exp)
                \item vincula(instr\_if(Exp, Bloq)): 
                    \subitem vincula(Exp) 
                    \subitem vincula(Bloq)
                \item vincula(instr\_if\_else(Exp, Bloq1, Bloq2)): 
                    \subitem vincula(Exp) 
                    \subitem vincula(Bloq1) 
                    \subitem vincula(Bloq2)
                \item vincula(instr\_while(Exp, Bloq)): 
                    \subitem vincula(Exp) 
                    \subitem vincula(Bloq)
                \item vincula(instr\_read(Exp)): 
                    \subitem vincula(Exp)
                \item vincula(instr\_write(Exp)): 
                    \subitem vincula(Exp)
                \item vincula(instr\_nl()): 
                    \subitem noop
                \item vincula(instr\_new(Exp)): 
                    \subitem vincula(Exp)
                \item vincula(instr\_del(Exp)): 
                    \subitem vincula(Exp)
                \item vincula(instr\_call(string, ParamsR)): 
                    \subitem vincula(ParamsR) 
                    \subitem \$.vinculo = vinculoDe(ts,string) 
                    \subitem if \$.vinculo == $\bot$ then 
                        \subsubitem error 
                    \subitem end if
                \item vincula(instr\_bloque(Bloq)): 
                    \subitem vincula(Bloq)
                \item vincula(si\_paramsR(ParamsRL)): 
                    \subitem vincula(ParamsRL)
                \item vincula(no\_paramsR()): 
                    \subitem noop
                \item vincula(muchos\_paramsR(ParamsRL, Exp)): 
                    \subitem vincula(ParamsRL) 
                    \subitem vincula(Exp)
                \item vincula(un\_paramsR(Exp)): 
                    \subitem vincula(Exp)
                \item vincula(asig(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(menor(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(mayor(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(menor\_igual(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(mayor\_igual(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(igual(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(no\_igual(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(suma(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(resta(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(and(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(or(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(mult(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(div(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(mod(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(negativo(Exp)): 
                    \subitem vincula(Exp)
                \item vincula(not(Exp)): 
                    \subitem vincula(Exp)
                \item vincula(index(Exp1, Exp2)): 
                    \subitem vincula(Exp1) 
                    \subitem vincula(Exp2)
                \item vincula(acceso(Exp, string)): 
                    \subitem vincula(Exp)
                \item vincula(indireccion(Exp)): 
                    \subitem vincula(Exp)
                \item vincula(lit\_ent(string)): 
                    \subitem noop
                \item vincula(lit\_real(string)): 
                    \subitem noop
                \item vincula(true()): 
                    \subitem noop
                \item vincula(false()): 
                    \subitem noop
                \item vincula(lit\_cadena(string)): 
                    \subitem noop
                \item vincula(iden(string)): 
                    \subitem \$.vinculo = vinculoDe(ts,string) 
                    \subitem if \$.vinculo == $\bot$ then 
                        \subsubitem error 
                    \subitem end if
                \item vincula(null()): 
                    \subitem noop
            \end{itemize}

    
    \section{Especificación del procesamiento de comprobación de tipos}
        A continuación se presentará la especificación del procesamiento de comprobación de tipos. Durante este procesamiento se comprueban las reglas de tipado del lenguaje:
        \begin{itemize}
            \item Se comprueba que las distintas construcciones del lenguaje estén
            correctamente tipadas.
            \item Se asocian tipos con estas construcciones.
        \end{itemize}
        Tiny es un lenguaje fuertemente tipado. Se crean dos nuevos tipos: ok y error para la gestión de errores.
        
        \begin{itemize}
            \item ambos-ok(T0,T1): 
                \subitem if T0 == ok \&\&  T1 == ok then
                    \subsubitem return ok
                \subitem else
                    \subsubitem return error
                \subitem end if
            \item aviso-error(T0,T1):
                \subitem if T0 == error then
                    \subsubitem error
                \subitem end if
                \subitem if T1 == error then
                    \subsubitem error
                \subitem end if
            \item aviso-error(T):
                \subitem if T == error then
                    \subsubitem error 
                \subitem end if
            \item ref!(T): \/// \textit{sigue la cadena de vínculos entre nombres de tipos sinónimos}
                \subitem if T = tipo\_iden(iden) then
                    \subsubitem let T.vinculo = dec\_tipo(T',iden) in 
                        \subsubitem \hspace{2em} return ref!(T')
                    \subsubitem end let
                \subitem else
                    \subsubitem return T
                \subitem end if
            \item es-designador(E) \/// \textit{determina cuándo una expresión es o no un designador}
                \subitem return E == iden(\_) $\vert \vert$ E == acceso(\_,\_) $\vert \vert$ E == index(\_,\_) $\vert \vert$ E == indireccion(\_)
            \item son\_unificables(muchos\_campos(LCampos1, Campo(T1, Iden1)), muchos\_campos(LCampos2, Campo(T2, Iden2)), esParamRef):
                \subitem if son\_unificables(T1, T2, esParamRef) then
                    \subsubitem return son\_unificables(LCampos1, LCampos2, esParamRef)
                \subitem else
                    \subsubitem return false
                \subitem end if
            \item son\_unificables(muchos\_campos(LCampos1, Campo1), un\_campo(Campo2), esParamRef):
                \subitem return false
            \item son\_unificables(un\_campo(Campo1), muchos\_campos(LCampos2, Campo2), esParamRef):
                \subitem return false
            \item son\_unificables(un\_campo(Campo(T1, Iden1)), un\_campo(Campo(T2, Iden2)), esParamRef): 
                \subitem return son\_unificables(T1, T2)
            \item son\_unificables(T1, T2, esParamRef): 
                \subitem if (T1 = T2) $\notin \Theta$ then
                    \subsubitem $\Theta = \Theta \cup \{T1 = T2\}$
                    \subsubitem return unificables(T1, T2, esParamRef)
                \subitem else
                    \subsubitem return true
                \subitem end if
            \item unificables(T1, T2, esParamRef): 
                \subitem let T1' = ref!(T1), T2' = ref!(T2) in
                    \subsubitem if T1' == T2' then
                        \subsubitem \hspace{2em} return true
                    \subsubitem else if T1' == tipo\_real(n1) \&\&  T2' == tipo\_int(n2) then \/// \textit{se asigna un int a un real}
                        \subsubitem \hspace{2em} return !esParamRef
                    \subsubitem else if T1' == tipo\_punt(T1a) \&\&  T2' == null(n2) then \/// \textit{se asigna null a un puntero}
                        \subsubitem \hspace{2em} return true
                    \subsubitem else if T1' == tipo\_array(T1a, n1) \&\&  T2' == tipo\_array(T2a, n1) then
                        \subsubitem \hspace{2em} return n1 == n2 \&\&  son\_unificables(T1a, T2a, esParamRef)
                    \subsubitem else if T1' == tipo\_struct(LCampos1) \&\&  T2' == tipo\_struct(LCampos2) then
                        \subsubitem \hspace{2em} return son\_unificables(LCampos1, LCampos2, esParamRef)
                    \subsubitem else if T1' == tipo\_punt(T1a) \&\&  T2' == tipo\_punt(T2a) then
                        \subsubitem \hspace{2em} return son\_unificables(T1a,T2a, esParamRef)
                    \subsubitem else
                        \subsubitem \hspace{2em} return false
                    \subsubitem end if 
                \subitem end let
            \item compatibles(T1,T2): 
                \subitem $\Theta = \{T1=T2\} $
                \subitem return unificables(T1,T2, false)
            \item compatibles(T1, T2, esParamRef): 
                \subitem $\Theta = \{T1=T2\} $
                \subitem return unificables(T1,T2, true)
            \item tipado(prog(Bloq)): 
                \subitem tipado(Bloq)
                \subitem \$.tipo = Bloq.tipo
            \item tipado(bloq(Decs, Insts)): 
                \subitem tipado(Decs)
                \subitem tipado(Insts)
                \subitem \$.tipo = ambos-ok(Decs.tipo, Insts.tipo)
            \item tipado(si\_decs(DecsAux)): 
                \subitem tipado(DecsAux)
                \subitem \$.tipo = DecsAux.tipo
            \item tipado(no\_decs()): 
                \subitem \$.tipo = ok
            \item tipado(muchas\_decs(DecsAux, Dec)): 
                \subitem tipado(DecsAux)
                \subitem tipado(Dec)
                \subitem \$.tipo = ambos-ok(DecsAux.tipo, Dec.tipo)
            \item tipado(una\_dec(Dec)): 
                \subitem tipado(Dec)
                \subitem \$.tipo = Dec.tipo
            \item tipado(dec\_var(T, Iden)): 
                \subitem \$.tipo = ok
            \item tipado(dec\_tipo(T, Iden)): 
                \subitem \$.tipo = ok
            \item tipado(dec\_proc(Iden, ParamsF, Bloq)): 
                \subitem tipado(Bloq)
                \subitem \$.tipo = Bloq.tipo
            \item tipado(si\_instr(InstsAux)): 
                \subitem tipado(InstsAux)
                \subitem \$.tipo = InstsAux.tipo
            \item tipado(no\_instr()): 
                \subitem \$.tipo = ok
            \item tipado(muchas\_instr(InstsAux, Inst)): 
                \subitem tipado(InstsAux)
                \subitem tipado(Inst)
                \subitem \$.tipo = ambos-ok(InstsAux.tipo, Inst.tipo)
            \item tipado(una\_instr(Inst)): 
                \subitem tipado(Inst)
                \subitem \$.tipo = Inst.tipo
            \item tipado(instr\_expr(Exp)): 
                \subitem tipado(Exp)
                \subitem if Exp.tipo == error then
                    \subsubitem \$.tipo = error
                \subitem else
                    \subsubitem aviso-error(Exp.tipo)
                    \subsubitem \$.tipo = ok
                \subitem end if
            \item tipado(instr\_if(Exp, Bloq)): 
                \subitem tipado(Exp)
                \subitem tipado(Bloq)
                \subitem if ref!(Exp.tipo) == tipo\_bool \&\& Bloq.tipo == ok then
                    \subsubitem \$.tipo = ok
                \subitem else
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(instr\_if\_else(Exp, Bloq1, Bloq2)): 
                \subitem tipado(Exp)
                \subitem tipado(Bloq1)
                \subitem tipado(Bloq2)
                \subitem if ref!(Exp.tipo) == tipo\_bool \&\&  Bloq1.tipo == ok \&\&  Bloq2.tipo == ok then
                    \subsubitem \$.tipo = ok
                \subitem else
                    \subsubitem aviso-error(Exp.tipo)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(instr\_while(Exp, Bloq)): 
                \subitem tipado(Exp)
                \subitem tipado(Bloq)
                \subitem if ref!(Exp.tipo) == tipo\_bool \&\&  Bloq.tipo == ok then
                    \subsubitem \$.tipo = ok
                \subitem else
                    \subsubitem aviso-error(Exp.tipo)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(instr\_read(Exp)): 
                \subitem tipado(Exp)
                \subitem t = ref!(Exp.tipo)
                \subitem if (t == tipo\_int $\vert \vert$ t == tipo\_real $\vert \vert$ t == tipo\_string) \&\&  es-designador(Exp) then
                    \subsubitem \$.tipo = ok
                \subitem else
                    \subsubitem aviso-error(Exp.tipo)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(instr\_write(Exp)): 
                \subitem tipado(Exp)
                \subitem t = ref!(Exp.tipo)
                \subitem if t == tipo\_int $\vert \vert$ t == tipo\_real $\vert \vert$ t == tipo\_string $\vert \vert$ t == tipo\_bool then
                    \subsubitem \$.tipo = ok
                \subitem else
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(instr\_nl()): 
                \subitem \$.tipo = ok
            \item tipado(instr\_new(Exp)): 
                \subitem tipado(Exp)
                \subitem if ref!(Exp.tipo) == tipo\_punt then
                    \subsubitem \$.tipo = ok
                \subitem else
                    \subsubitem aviso-error(Exp.tipo)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(instr\_del(Exp)): 
                \subitem tipado(Exp)
                \subitem if ref!(Exp.tipo) == tipo\_punt then
                    \subsubitem \$.tipo = ok
                \subitem else
                    \subsubitem aviso-error(Exp.tipo)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item llamadas\_compatibles(si\_paramF(ParamsFL), si\_paramsR(ParamsRL)): 
                \subitem return llamadas\_compatibles(ParamsFL, ParamsRL)
            \item llamadas\_compatibles(no\_paramF(), no\_paramsR()): 
                \subitem return ok
            \item llamadas\_compatibles(muchos\_paramsF(ParamsFL, param(T, Iden)), muchos\_paramsR(ParamsRL, Exp)): 
                \subitem if es-designador(Exp) \&\&  compatibles(Exp.tipo, T) then
                    \subsubitem return llamadas\_compatibles(ParamsFL, ParamsRL)
                \subitem else
                    \subsubitem aviso-error(Exp)
                    \subsubitem return error
                \subitem end if
            \item llamadas\_compatibles(muchos\_paramsF(ParamsFL, param\_ref(T, Iden)), muchos\_paramsR(ParamsRL, Exp)): 
                \subitem if compatibles(Exp.tipo, T) then
                    \subsubitem return llamadas\_compatibles(ParamsFL, ParamsRL)
                \subitem else
                    \subsubitem aviso-error(Exp)
                    \subsubitem return error
                \subitem end if
            \item llamadas\_compatibles(un\_paramF(param(T, Iden)), un\_paramsR(Exp)): 
                \subitem if compatibles(T, Exp.tipo) then
                    \subsubitem return ok
                \subitem else
                    \subsubitem aviso-error(Exp)
                    \subsubitem return error
                \subitem end if
            \item llamadas\_compatibles(un\_paramF(param\_ref(T, Iden)), un\_paramsR(Exp)): 
                \subitem if !es-designador(Exp) then
                    \subsubitem error
                \subitem if compatibles(T, Exp.tipo, true) then
                    \subsubitem return ok
                \subitem else
                    \subsubitem aviso-error(Exp)
                    \subsubitem return error
                \subitem end if
            \item tipado(instr\_call(Iden, ParamsR)): 
                \subitem tipado(paramsR) \/// \textit{primero tipamos los parámetros R}
                \subitem if Iden.vinculo $\neq$ dec\_proc(\_,\_) then
                    \subsubitem aviso-error(Iden)
                    \subsubitem \$.tipo = error
                    \subsubitem return
                \subitem let Iden.vinculo = dec\_proc(Iden, ParamsF, Bloq) in
                    \subsubitem if num\_elems(paramsF) == num\_elems(ParmsR) then \/// \textit{luego verificamos cantidad}
                        \subsubitem \hspace{2em} \$.tipo = llamadas\_compatibles(ParamsF, ParamsR) \/// \textit{por último, compatibilidad}
                    \subsubitem else
                        \subsubitem \hspace{2em} \$.tipo = error
                    \subsubitem end if
                \subitem end let
            \item tipado(no\_paramsR()): 
                \subitem \$.tipo = ok
            \item tipado(si\_paramsR(ParamsRL)): 
                \subitem tipado(ParamsRL)
                \subitem \$.tipo = ParamsRL.tipo
            \item tipado(muchos\_paramsR(ParamsRL, Exp)): 
                \subitem tipado(ParamsRL)
                \subitem tipado(Exp)
                \subitem if Exp.tipo == error then
                    \subsubitem \$.tipo = error
                \subitem else
                    \subsubitem \$.tipo = ParamsRL.tipo
                \subitem end if
            \item tipado(un\_paramsR(Exp)): 
                \subitem tipado(Exp)
                \subitem if Exp.tipo == error then
                    \subsubitem \$.tipo = error
                \subitem else
                    \subsubitem \$.tipo = ok
                \subitem end if
            \item num\_elems(si\_paramF(ParamsFL)):
                \subitem num\_elems(ParamsFL)
            \item num\_elems(no\_paramF()): 
                \subitem return 0
            \item num\_elems(muchos\_paramsF(ParamsFL,\_)): 
                \subitem return 1 + num\_elems(ParamsFL)
            \item num\_elems(un\_paramF(\_)): 
                \subitem return 1
            \item num\_elems(si\_paramsR(ParamsRL)): 
                \subitem num\_elems(ParamsRL) 
            \item num\_elems(no\_paramsR()): 
                \subitem return 0
            \item num\_elems(muchos\_paramsR(ParamsRL,\_)): 
                \subitem return 1 + num\_elems(ParamsRL)
            \item num\_elems(un\_paramsR(\_)): 
                \subitem return 1
            \item tipado(instr\_bloque(Bloq)): 
                \subitem tipado(Bloq)
                \subitem \$.tipo = Bloq.tipo
            \item tipado(asig(ExpI,ExpD)): 
                \subitem tipado(ExpI) 
                \subitem tipado(ExpD) 
                \subitem if es-designador(ExpI) then
                    \subsubitem if compatibles(ExpI.tipo,ExpD.tipo) then 
                        \subsubitem \hspace{2em}
                        \$.tipo = ExpI.tipo
                    \subsubitem else 
                        \subsubitem \hspace{2em} aviso-error(\$)
                        \subsubitem \hspace{2em} \$.tipo = error 
                    \subsubitem end if 
                \subitem else 
                    \subsubitem aviso-error(\$) \/// \textit{la parte izq. debe ser un designador}
                    \subsubitem \$.tipo = error 
                \subitem end if
            \item tipado-bin-comp(E1, E2, E): 
                \subitem tipado(E1) 
                \subitem tipado(E2) 
                \subitem t1 = ref!(E1.tipo) 
                \subitem t2 = ref!(E2.tipo) 
                \subitem if ((t1 == tipo\_int $\vert \vert$ t1 == tipo\_real) \&\&  (t2 == tipo\_int $\vert \vert$ t2 == tipo\_real)) $\vert \vert$ 
                    (t1 == tipo\_bool \&\&  t2 == tipo\_bool) $\vert \vert$ 
                    (t1 == tipo\_string \&\&  t2 == tipo\_string) then
                    \subsubitem E.tipo = tipo\_bool
                \subitem else 
                    \subsubitem aviso-error(E)
                    \subsubitem E.tipo = error
                \subitem end if
            \item tipado(menor(Exp1, Exp2)):
                \subitem tipado-bin-comp(Exp1, Exp2, \$)
            \item tipado(mayor(Exp1, Exp2)): 
                \subitem tipado-bin-comp(Exp1, Exp2, \$)
            \item tipado(menor\_igual(Exp1, Exp2)): 
                \subitem tipado-bin-comp(Exp1, Exp2, \$)
            \item tipado(mayor\_igual(Exp1, Exp2)): 
                \subitem tipado-bin-comp(Exp1, Exp2, \$)
            \item tipado-bin-igualdad(E1, E2, E): 
                \subitem tipado(E1) 
                \subitem tipado(E2) 
                \subitem t1 = ref!(E1.tipo) 
                \subitem t2 = ref!(E2.tipo) 
                \subitem if ((t1 == tipo\_int $\vert \vert$ t1 == tipo\_real) \&\&  (t2 == tipo\_int $\vert \vert$ t2 == tipo\_real)) $\vert \vert$ 
                    (t1 == tipo\_bool \&\&  t2 == tipo\_bool) $\vert \vert$ 
                    (t1 == tipo\_string \&\&  t2 == tipo\_string) $\vert \vert$ 
                    ((t1 == tipo\_punt $\vert \vert$ t1 == null) \&\&  (t2 == tipo\_punt $\vert \vert$ t2 == null)) then
                    \subsubitem E.tipo = tipo\_bool
                \subitem else
                    \subsubitem aviso-error(E)
                    \subsubitem E.tipo = error
                \subitem end if
            \item tipado(igual(Exp1, Exp2)): 
                \subitem tipado-bin-igualdad(Exp1, Exp2, \$)
            \item tipado(no\_igual(Exp1, Exp2)): 
                \subitem tipado-bin-igualdad(Exp1, Exp2, \$)
            \item tipado-bin-arit(E1, E2, E): 
                \subitem tipado(E1) 
                \subitem tipado(E2) 
                \subitem t1 = ref!(E1.tipo) 
                \subitem t2 = ref!(E2.tipo) 
                \subitem if t1 == tipo\_int \&\&  t2 == tipo\_int then
                    \subsubitem E.tipo = tipo\_int
                \subitem else if (t1 == tipo\_int $\vert \vert$ t1 == tipo\_real) \&\&  (t2 == tipo\_int $\vert \vert$ t2 == tipo\_real) then
                    \subsubitem E.tipo = tipo\_real
                \subitem else 
                    \subsubitem aviso-error(E)
                    \subsubitem E.tipo = error
                \subitem end if
            \item tipado(suma(Exp1, Exp2)): 
                \subitem tipado-bin-arit(Exp1, Exp2, \$)
            \item tipado(resta(Exp1, Exp2)): 
                \subitem tipado-bin-arit(Exp1, Exp2, \$)
            \item tipado(mul(Exp1, Exp2)): 
                \subitem tipado-bin-arit(Exp1, Exp2, \$)
            \item tipado(div(Exp1, Exp2)): 
                \subitem tipado-bin-arit(Exp1, Exp2, \$)
            \item tipado-bin-logi(E1, E2, E): 
                \subitem tipado(E1) 
                \subitem tipado(E2) 
                \subitem t1 = ref!(E1.tipo) 
                \subitem t2 = ref!(E2.tipo) 
                \subitem if t1 == tipo\_bool \&\&  t2 == tipo\_bool then
                    \subsubitem E.tipo = tipo\_bool
                \subitem else
                    \subsubitem aviso-error(E)
                    \subsubitem E.tipo = error
                \subitem end if
            \item tipado(and(Exp1, Exp2)): 
                \subitem tipado-bin-logi(Exp1, Exp2, \$)
            \item tipado(or(Exp1, Exp2)): 
                \subitem tipado-bin-logi(Exp1, Exp2, \$)
            \item tipado(mod(Exp1, Exp2)): 
                \subitem tipado(Exp1) 
                \subitem tipado(Exp2) 
                \subitem t1 = ref!(Exp1.tipo) 
                \subitem t2 = ref!(Exp2.tipo) 
                \subitem if t1 == tipo\_int \&\&  t2 == tipo\_int then
                    \subsubitem \$.tipo = tipo\_int
                \subitem else 
                    \subsubitem aviso-error(\$)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(negativo(Exp)): 
                \subitem tipado(Exp) 
                \subitem t = ref!(Exp.tipo) 
                \subitem if t == tipo\_int $\vert \vert$ t == tipo\_real then
                    \subsubitem \$.tipo = t
                \subitem else 
                    \subsubitem aviso-error(t)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(not(Exp)): 
                \subitem tipado(Exp) 
                \subitem if ref!(Exp.tipo) == tipo\_bool then
                    \subsubitem \$.tipo = tipo\_bool
                \subitem else 
                    \subsubitem aviso-error(t)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(index(Exp, LitEnt)): 
                \subitem tipado(Exp) 
                \subitem tipado(LitEnt) 
                \subitem if ref!(Exp.tipo) == tipo\_array(T, LitEnt) \&\&  ref!(LitEnt.tipo) == tipo\_int then
                    \subsubitem \$.tipo = T
                \subitem else 
                    \subsubitem aviso-error(Exp)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(acceso(Exp, Iden)): 
                \subitem tipado(Exp) 
                \subitem if ref!(Exp.tipo) == tipo\_struct(LCampos) then
                    \subsubitem \$.tipo = esCampoDe(Iden, LCampos)
                \subitem else 
                    \subsubitem aviso-error(Exp.tipo)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item esCampoDe(Iden, muchos\_campos(LCampos, Campo)): 
                \subitem t = esCampoDe(Iden, Campo) 
                \subitem if t == error then
                    \subsubitem return esCampoDe(Iden, LCampos)
                \subitem else 
                    \subsubitem return t
                \subitem end if
            \item esCampoDe(Iden, un\_campo(LCampos, Campo)): 
                \subitem return esCampoDe(Iden, Campo)
            \item esCampoDe(Iden1(N1), campo(T, Iden2(N2))): 
                \subitem if N1 == N2 then
                    \subsubitem return T
                \subitem else 
                    \subsubitem return error
                \subitem end if
            \item tipado(indireccion(Exp)): 
                \subitem tipado(Exp) 
                \subitem if Exp.tipo == tipo\_punt(T) then
                    \subsubitem \$.tipo = T
                \subitem else 
                    \subsubitem aviso-error(Exp.tipo)
                    \subsubitem \$.tipo = error
                \subitem end if
            \item tipado(lit\_ent(N)): 
                \subitem \$.tipo = tipo\_int
            \item tipado(lit\_real(N)): 
                \subitem \$.tipo = tipo\_real
            \item tipado(true(N)): 
                \subitem \$.tipo = tipo\_bool
            \item tipado(false(N)): 
                \subitem \$.tipo = tipo\_bool
            \item tipado(lit\_cadena(N)): 
                \subitem \$.tipo = tipo\_string
            \item tipado(iden(N)): 
                \subitem if \$.vinculo == Dec\_var(T, I) then
                    \subsubitem let \$.vinculo = Dec\_var(T, I) in 
                        \subsubitem \hspace{2em} \$.tipo = T
                    \subsubitem end let
                \subitem else if \$.vinculo == param\_ref(T, I) then
                    \subsubitem let \$.vinculo = param\_ref(T, I) in 
                        \subsubitem \hspace{2em} \$.tipo = T
                    \subsubitem end let
                \subitem else if \$.vinculo == param(T, I) then
                    \subsubitem let \$.vinculo = param(T, I) in 
                        \subsubitem \hspace{2em} \$.tipo = T
                    \subsubitem end let
                \subitem else
                    \subsubitem error
                \subitem end if
            \item tipado(null()): 
                \subitem \$.tipo = null
        \end{itemize}


    \section{Especificación del proceso de asignación de espacio}

        Dado que, para acceder a los objetos designados, es necesario computar direcciones, será necesario también equipar la máquina con instrucciones que funcionen con direccionamiento indirecto. A continuación se definirá la asignación de espacio.
        Esta se hará en dos pasadas, como el proceso de vinculación. 

        \begin{itemize}
            \item var dir = 0 \/// \textit{contador de direcciones}
            \item var max\_dir = 0 \/// \textit{mantiene la máxima dirección asignada}
            \item var nivel = 0
            \item asig-espacio(prog(Bloq)): 
                \subitem asig-espacio(Bloq)
            \item asig-espacio(bloq(Decs, Insts)): 
                \subitem dir\_ant = dir
                \subitem asig-espacio1(Decs)
                \subitem asig-espacio2(Decs)
                \subitem asig-espacio(Insts)
                \subitem dir = dir\_ant
            \item inc\_dir(inc): \/// \textit{se incrementa dir y se mantiene max\_dir} 
                \subitem dir += inc
                \subitem if dir $>$ max\_dir then 
                    \subsubitem max\_dir = dir            
        \end{itemize}
        \textbf{\/// Primera pasada}
        \begin{itemize}
            \item asig-espacio1(si\_decs(DecsAux)): 
                \subitem asig-espacio1(DecsAux)
            \item asig-espacio1(no\_decs()): 
                \subitem noop
            \item asig-espacio1(muchas\_decs(DecsAux, Dec)): 
                \subitem asig-espacio1(DecsAux)
                \subitem asig-espacio1(Dec)
            \item asig-espacio1(una\_dec(Dec)): 
                \subitem asig-espacio1(Dec)
            \item asig-espacio1(dec\_var(T, string)): 
                \subitem asig-tam1(T)
                \subitem \$.dir = dir
                \subitem \$.nivel = nivel
                \subitem inc\_dir(T.tam)
            \item asig-espacio1(dec\_tipo(T, string)): 
                \subitem asig-tam1(T)
            \item asig-espacio1(dec\_proc(string, ParamsF, Bloq)): 
                \subitem dir\_ant = dir
                \subitem max\_dir\_ant = max\_dir
                \subitem nivel$++$
                \subitem \$.nivel = nivel
                \subitem dir = 0
                \subitem max\_dir = 0
                \subitem asig-espacio1(ParamsF)
                \subitem asig-espacio2(ParamsF)
                \subitem asig-espacio(Bloq)
                \subitem \$.tam = max\_dir
                \subitem dir = dir\_ant
                \subitem max\_dir = max\_dir\_ant
                \subitem nivel$--$
            \item asig-espacio1(si\_paramF(ParamsFL)): 
                \subitem asig-espacio1(ParamsFL)
            \item asig-espacio1(no\_paramF()): 
                \subitem noop
            \item asig-espacio1(muchos\_paramsF(ParamsFL, Param)): 
                \subitem asig-espacio1(ParamsFL)
                \subitem asig-espacio1(Param)
            \item asig-espacio1(un\_paramF(Param)): 
                \subitem asig-espacio1(Param)
            \item asig-espacio1(param\_ref(T, string)): 
                \subitem asig-tam1(T)
                \subitem \$.nivel = nivel
                \subitem \$.dir = dir
                \subitem inc\_dir(T.tam)
            \item asig-espacio1(param\_no\_ref(T, string)): 
                \subitem asig-tam1(T)
                \subitem \$.nivel = nivel
                \subitem \$.dir = dir
                \subitem inc\_dir(T.tam)
            \item asig-tam1(tipo\_array(T, tam)): 
                \subitem asig-tam1(T)
                \subitem \$.tam = T.tam * tam
            \item asig-tam1(tipo\_punt(T)): 
                \subitem if T $\neq$ tipo\_iden(iden) then
                    \subsubitem asig-tam1(T)
                \subitem \$.tam = 1
            \item asig-tam1(tipo\_struct(LCampos)): 
                \subitem dir\_ant = dir
                \subitem dir = 0
                \subitem asig-espacio1(LCampos)
                \subitem \$.tam = dir
                \subitem dir = dir\_ant
            \item asig-espacio1(muchos\_campos(LCampos, Campo)): 
                \subitem asig-espacio1(LCampos)
                \subitem asig-espacio1(Campo)
            \item asig-espacio1(un\_campo(Campo)): 
                \subitem asig-espacio1(Campo)
            \item asig-espacio1(campo(T, string)): 
                \subitem \$.desp = dir
                \subitem asig.tam1(T)
                \subitem dir += T.tam
            \item asig-tam1(tipo\_int()): 
                \subitem \$.tam = 1
            \item asig-tam1(tipo\_real()): 
                \subitem \$.tam = 1
            \item asig-tam1(tipo\_bool()): 
                \subitem \$.tam = 1
            \item asig-tam1(tipo\_string()): 
                \subitem \$.tam = 1
            \item asig-tam1(tipo\_iden(string)): 
                \subitem \$.tam = 1
        \end{itemize}
        \textbf{\/// Segunda pasada}
        \begin{itemize}
            \item asig-espacio2(si\_decs(DecsAux)): 
                \subitem asig-espacio2(DecsAux)
            \item asig-espacio2(no\_decs()): 
                \subitem noop
            \item asig-espacio2(muchas\_decs(DecsAux, Dec)): 
                \subitem asig-espacio2(DecsAux)
                \subitem asig-espacio2(Dec)
            \item asig-espacio2(una\_dec(Dec)): 
                \subitem asig-espacio2(Dec)
            \item asig-espacio2(dec\_var(T, string)): 
                \subitem asig-tam2(T)
            \item asig-espacio2(dec\_tipo(T, string)): 
                \subitem asig-tam2(T)
            \item asig-espacio2(dec\_proc(string, ParamsF, Bloq)): 
                \subitem noop
            \item asig-espacio2(si\_paramF(ParamsFL)): 
                \subitem asig-espacio2(ParamsFL)
            \item asig-espacio2(no\_paramF()): 
                \subitem noop
            \item asig-espacio2(muchos\_paramsF(ParamsFL, Param)): 
                \subitem asig-espacio2(ParamsFL)
                \subitem asig-espacio2(Param)
            \item asig-espacio2(un\_paramF(Param)): 
                \subitem asig-espacio2(Param) 
            \item asig-espacio2(param\_ref(T, string)): 
                \subitem asig-tam2(T)
            \item asig-espacio2(param(T, string)): 
                \subitem asig-tam2(T)
            \item asig-tam2(tipo\_array(T, string)): 
                \subitem asig-tam2(T)
            \item asig-tam2(tipo\_punt(T)): 
                \subitem if T = tipo\_iden(iden) then
                    \subsubitem let T.vinculo = dec\_tipo(T’,id) in
                    \subsubitem T.tam = T’.tam
                \subitem else
                    \subsubitem asig-tam2(T)
                \subitem end if
            \item asig-tam2(tipo\_struct(LCampos)): 
                \subitem asig-espacio2(LCampos)
            \item asig-espacio2(muchos\_campos(LCampos, Campo)): 
                \subitem asig-espacio2(LCampos)
                \subitem asig-espacio2(Campo)
            \item asig-espacio2(un\_campo(Campo)): 
                \subitem asig-espacio2(Campo)
            \item asig-espacio2(campo(T, string)): 
                \subitem asig.tam2(T)
            \item asig-tam2(tipo\_int()): 
                \subitem noop
            \item asig-tam2(tipo\_real()): 
                \subitem noop
            \item asig-tam2(tipo\_bool()): 
                \subitem noop
            \item asig-tam2(tipo\_string()): 
                \subitem noop
            \item asig-tam2(tipo\_iden(string)): 
                \subitem noop
        \end{itemize} 
        \textbf{\/// Única pasada}
        \begin{itemize}
            \item asig-espacio(si\_instr(InstsAux)): 
                \subitem asig-espacio(InstsAux)
            \item asig-espacio(no\_instr()): 
                \subitem noop
            \item asig-espacio(muchas\_instr(InstsAux, Inst)): 
                \subitem asig-espacio(InstsAux)
                \subitem asig-espacio(Inst)
            \item asig-espacio(una\_instr(Inst)): 
                \subitem asig-espacio(Inst)
            \item asig-espacio(instr\_expr(Exp)): 
                \subitem noop
            \item asig-espacio(instr\_if(Exp, Bloq)): 
                \subitem asig-espacio(Bloq)
            \item asig-espacio(instr\_if\_else(Exp, Bloq1, Bloq2)): 
                \subitem asig-espacio(Bloq1)
                \subitem asig-espacio(Bloq2)
            \item asig-espacio(instr\_while(Exp, Bloq)): 
                \subitem asig-espacio(Bloq)
            \item asig-espacio(instr\_read(Exp)): 
                \subitem noop
            \item asig-espacio(instr\_write(Exp)): 
                \subitem noop
            \item asig-espacio(instr\_nl()): 
                \subitem noop
            \item asig-espacio(instr\_new(Exp)): 
                \subitem noop
            \item asig-espacio(instr\_del(Exp)): 
                \subitem noop
            \item asig-espacio(instr\_call(string, ParamsR)): 
                \subitem asig-espacio(ParamsR)
            \item asig-espacio(instr\_bloque(Bloq)): 
                \subitem asig-espacio(Bloq)
            \item asig-espacio(si\_paramsR(ParamsRL)): 
                \subitem asig-espacio(ParamsRL)
            \item asig-espacio(no\_paramsR()): 
                \subitem noop
            \item asig-espacio(muchos\_paramsR(ParamsRL, Exp)): 
                \subitem asig-espacio(ParamsRL)
            \item asig-espacio(un\_paramsR(Exp)): 
                \subitem noop
            \item asig-espacio(asig(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(menor(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(mayor(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(menor\_igual(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(mayor\_igual(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(igual(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(no\_igual(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(suma(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(resta(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(and(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(or(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(mult(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(div(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(mod(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(negativo(Exp)): 
                \subitem noop
            \item asig-espacio(not(Exp)): 
                \subitem noop
            \item asig-espacio(index(Exp1, Exp2)): 
                \subitem noop
            \item asig-espacio(acceso(Exp, string)): 
                \subitem noop
            \item asig-espacio(indireccion(Exp)): 
                \subitem noop
            \item asig-espacio(lit\_ent(string)): 
                \subitem noop
            \item asig-espacio(lit\_real(string)): 
                \subitem noop
            \item asig-espacio(true()): 
                \subitem noop
            \item asig-espacio(false()): 
                \subitem noop
            \item asig-espacio(lit\_cadena(string)): 
                \subitem noop
            \item asig-espacio(iden(string)): 
                \subitem noop
            \item asig-espacio(null()): 
                \subitem noop
        \end{itemize}
    
    \section{Descripción del repertorio de instrucciones de la máquina-p necesarias para soportar la traducción de Tiny a código-p}
        \subsubsection*{Instrucciones de movimientos de datos}
            \begin{itemize}
                \item \textbf{apila\_int(int val):} usado para apilar en la pila de evaluación literales para ser usados en las expresiones y los valores necesarios para calcular el tamaño en memoria de algunos tipos.
                \item \textbf{apila\_real(int val):} usado para apilar en la pila de evaluación valores reales.
                \item \textbf{apila\_bool(boolean val):} usado para apilar en la pila de evaluación valores booleanos verdaderos y falsos.
                \item \textbf{apila\_string(string val):} usado para aplicar en la pila de evaluación el valor $val$ de tipo string.
                \item \textbf{apilad(int nivel):} usado para apilar en la pila de evaluación el valor del display de nivel $nivel$.
                \item \textbf{apila\_ind():} usado para llevar el valor de un designador a la cima de la pila.
                \item \textbf{desapila\_ind():} desapila un valor $v$ y una dirección $d$ de la pila de evaluación (primero $v$, después $d$), y actualiza el contenido de la celda $d$ en la memoria de datos a $v$.
                \item \textbf{copia(int tam):} al terminar las instrucciones de paso de parámetro, puede darse el caso donde en la cima de la pila de evaluación se encuentre la dirección del objeto, entonces solo habrá que copiar dicho valor a la dirección de comienzo del parámetro formal, que es la siguiente de la pila. $tam$ es el tamaño del tipo que tiene que copiarse.
                \item \textbf{desapilad(int nivel):} desapila una dirección $d$ de la pila de evaluación en el display de nivel $nivel$.
            \end{itemize}
        \subsubsection*{Instrucciones de salto}
            \begin{itemize}
                \item \textbf{ir\_a(int dir):} usado en la instrucción de bucle while para volver al comienzo del bucle y en la instrucción de llamada a una función (call) para ir al comienzo de sus instrucciones.
                \item \textbf{ir\_f(int dir):} usado en las instrucciones con expresiones condicionales para saltar a la instrucción $dir$ si el valor en la cima de la pila es falso.
                \item \textbf{ir\_ind():} usado para desapilar una dirección de la pila de evaluación y realizar un salto a la misma. Vuelve a la instrucción siguiente de la llamada realizada con anterioridad a un subprograma.
            \end{itemize}
        \subsubsection*{Gestión de memoria dinámica}
            \begin{itemize}
                \item \textbf{alloc(int tam):} reservar el número especificado por $tam$ de celdas en memoria dinámica (instrucción new).
                \item \textbf{dealloc(int tam):} considera libres $tam$ celdas de memoria dinámica, especificadas por la dirección en la cima de la pila de evaluación (instrucción delete).
            \end{itemize}
        \subsubsection*{Soporte a la ejecución de procedimientos}
            \begin{itemize}
                \item \textbf{activa(int nivel,int tam, int dirretorno):} reserva espacio en el segmento de pila de registros de activación para ejecutar un procedimiento que tiene nivel de anidamiento $nivel$ y tamaño de datos locales $tam$.
                \item \textbf{desactiva(int nivel, int tam):} libera el espacio ocupado por el registro de activación actual, restaurando adecuadamente el estado de la máquina.
                \item \textbf{dup():} consulta el valor $v$ de la cima de la pila de evaluación, y apila de nuevo dicho valor.
                \item \textbf{stop():} detiene la máquina. Para tras traducir el código del programa principal y da paso a la traducción de los subprogramas apilados.
                \item \textbf{emit(Instruccion i):} emite una instrucción de la máquina virtual.
                \item \textbf{desplazamiento(LCampos Cs, string tam):} recupera el desplazamiento de un campo de una lista de campos.
            \end{itemize}
        
    \section{Especificación del proceso de etiquetado}
    Cada vez que se genera una instrucción de salto, es necesario conocer a qué dirección saltar. Se realiza entonces un procesamiento previo que, para cada nodo del AST que dé lugar a código, fije la dirección de la primera instrucción que conforma dicho código, así como la dirección de la instrucción que sigue a la última instrucción (instrucción siguiente). Durante el  etiquetado se cuentan las instrucciones que se van a
    emitir posteriormente, durante la generación.
    
    \begin{itemize}
        \item var sub\_pendientes = pila-vacia()
        \item var etq = 0 \/// \textit{cuenta la
        dirección de la instrucción que habrá de emitirse actualmente}
        \item etiquetado(prog(Bloq)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Bloq)
            \subitem etq++
            \subitem while !es-vacia(sub\_pendientes)
                \subsubitem sub = cima(sub\_pendientes)
                \subsubitem desapila\_ind(sub\_pendientes)
                \subsubitem let sub = dec\_proc(string,ParamsFL,Bloq) in
                    \subsubitem \hspace{2em} sub.prim = etq
                    \subsubitem \hspace{2em} etq$++$
                    \subsubitem \hspace{2em} etiquetado(Bloq)
                    \subsubitem \hspace{2em} etq += 2
                    \subsubitem \hspace{2em} sub.sig = etq
                \subsubitem end let
            \subitem end while
            \subitem \$.sig = etq
        \item etiquetado(bloq(Decs, Insts)): 
            \subitem \$.prim = etq
            \subitem recolecta\_subs(Decs)
            \subitem etiquetado(Insts)
            \subitem \$.sig = etq
        \item etiquetado(si\_instr(InstAux)): 
            \subitem etiquetado(InstAux)
        \item etiquetado(no\_instr()): 
            \subitem noop
        \item etiquetado(muchas\_instr(InstsAux, Inst)): 
            \subitem \$.prim = etq
            \subitem etiquetado(InstsAux)
            \subitem etiquetado(Inst)
            \subitem \$.sig = etq
        \item etiquetado(una\_instr(Inst)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Inst)
            \subitem \$.sig = etq
        \item etiquetado(instr\_expr(Exp)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(instr\_if(Exp, Bloq)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etiquetado-acc-val(Exp)
            \subitem etq++
            \subitem etiquetado(Bloq)
            \subitem \$.sig = etq
        \item etiquetado(instr\_if\_else(Exp, Bloq1, Bloq2)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etiquetado-acc-val(Exp)
            \subitem etq++
            \subitem etiquetado(Bloq1)
            \subitem etq++
            \subitem \$.else = etq
            \subitem etiquetado(Bloq2)
            \subitem \$.sig = etq
        \item etiquetado(instr\_while(Exp, Bloq)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etiquetado-acc-val(Exp)
            \subitem etq++
            \subitem etiquetado(Bloq)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(instr\_read(Exp)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etq += 2
            \subitem \$.sig = etq
        \item etiquetado(instr\_write(Exp)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(instr\_nl()): 
            \subitem \$.prim = etq
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(instr\_new(Exp)):  
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem if ref!(Exp.tipo) == tipo\_punt
                \subsubitem etq++
            \subitem end if
            \subitem etq ++
            \subitem \$.sig = etq
        \item etiquetado(instr\_del(Exp)):
            \subitem \$.prim = etq
            \subitem if ref!(Exp.tipo) == tipo\_punt
                \subsubitem etq++
            \subitem end if 
            \subitem etq ++ 
            \subitem \$.sig = etq
        \item etiquetado(instr\_call(string, ParamsR)): 
            \subitem \$.prim = etq
            \subitem etq++
            \subitem etiquetado-paso-param(\$.vinculo,ParamsR)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(instr\_bloque(Bloq)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Bloq)
            \subitem \$.sig = etq
        \item etiquetado(si\_paramsR(ParamsRL)): 
            \subitem \$.prim = etq
            \subitem etiquetado(ParamsRL)
            \subitem \$.sig = etq
        \item etiquetado(no\_paramsR()): 
            \subitem \$.prim = etq
            \subitem \$.sig = etq
        \item etiquetado(muchos\_paramsR(ParamsRL, Exp)): 
            \subitem \$.prim = etq
            \subitem etiquetado(ParamsRL)
            \subitem etiquetado(Exp)
            \subitem \$.sig = etq
        \item etiquetado(un\_paramsR(Exp)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem \$.sig = etq
        \item etiquetado(asig(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp1)
            \subitem etiquetado(Exp2)
            \subitem if ref!(Exp1.tipo) == tipo\_real \&\& ref!(Exp2.tipo) == tipo\_int
                \subsubitem if es-designador(Exp2)
                    \subsubitem \hspace{2em} etq += 3
                \subsubitem else
                    \subsubitem \hspace{2em} etq += 2
                \subsubitem end if
            \subitem else
                \subsubitem etq++
            \subitem end if
            \subitem \$.sig = etq
        \item etiquetado(menor(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(mayor(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(menor\_igual(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(mayor\_igual(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(igual(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(no\_igual(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(suma(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(resta(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(and(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(or(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(mult(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(div(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(mod(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado-opnds(Exp1, Exp2)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(negativo(Exp)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etq-acc-val(Exp)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(not(Exp)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etq-acc-val(Exp)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(index(Exp1, Exp2)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp1)
            \subitem etiquetado(Exp2)
            \subitem etq-acc-val(Exp2)
            \subitem if ref!(Exp1.tipo) == tipo\_array
                \subsubitem etq++
            \subitem end if
            \subitem etq += 2
            \subitem \$.sig = etq
        \item etiquetado(acceso(Exp, string)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etq += 2
            \subitem \$.sig = etq
        \item etiquetado(indireccion(Exp)): 
            \subitem \$.prim = etq
            \subitem etiquetado(Exp)
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(lit\_ent(string)): 
            \subitem \$.prim = etq
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(lit\_real(string)): 
            \subitem \$.prim = etq
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(true()): 
            \subitem \$.prim = etq
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(false()): 
            \subitem \$.prim = etq
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(lit\_cadena(string)): 
            \subitem \$.prim = etq
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado(iden(string)): 
            \subitem \$.prim = etq
            \subitem if \$.vinculo == dec\_var then
                \subsubitem etiquetado-acc-id(\$.vinculo)
            \subitem else if \$.vinculo == param then
                \subsubitem etiquetado-acc-id(\$.vinculo)
            \subitem else if \$.vinculo == param\_ref then
                \subsubitem etiquetado-acc-id(\$.vinculo)
            \subitem end if
            \subitem \$.sig = etq
        \item etiquetado(null()): 
            \subitem \$.prim = etq
            \subitem etq++
            \subitem \$.sig = etq
        \item etiquetado-opnds(Opnd0,Opnd1): 
            \subitem if ref!(Opnd0.tipo) == tipo\_int \&\& ref!(Opnd1.tipo) == tipo\_real
                \subsubitem etiquetado(Opnd0)
                \subsubitem etiquetado-acc-val(Opnd0)
                \subsubitem etq++
                \subsubitem etiquetado(Opnd1)
                \subsubitem etiquetado-acc-val(Opnd1)
            \subitem else if ref!(Opnd0.tipo) == tipo\_real \&\& ref!(Opnd1.tipo) == tipo\_int
                \subsubitem etiquetado(Opnd0)
                \subsubitem etiquetado-acc-val(Opnd0)
                \subsubitem etiquetado(Opnd1)
                \subsubitem etiquetado-acc-val(Opnd1)
                \subsubitem etq++
            \subitem else
                \subsubitem etiquetado(Opnd0)
                \subsubitem etiquetado-acc-val(Opnd0)
                \subsubitem etiquetado(Opnd1)
                \subsubitem etiquetado-acc-val(Opnd1)
            \subitem end if
        \item etiquetado-acc-id(dec\_var(T, string)): 
            \subitem if \$.nivel = 0 then
                \subsubitem etq++
            \subitem else
                \subsubitem etiquetado-acc-var(\$.vinculo)
            \subitem end if
        \item etiquetado-acc-id(param(T, string)): 
            \subitem etiquetado-acc-var(\$.vinculo)
        \item etiquetado-acc-id(param\_ref(T, string)): 
            \subitem etiquetado-acc-var(\$.vinculo)
            \subitem etq++
        \item etiquetado-acc-var(V): 
            \subitem etq += 3
        \item etiquetado-acc-val(E): 
            \subitem if es-designador(E) then
                \subsubitem etq++
            \subitem end if
        \item etiquetado-paso-param(dec\_proc(string,ParamsF,Bloq),ParamsR): 
            \subitem etiquetado-paso-param-aux(ParamsF, ParamsR)
        \item etiquetado-paso-param-aux(si\_paramF(ParamsFL), si\_paramsR(ParamsRL)): 
            \subitem etiquetado-paso-param-aux(ParamsFL, ParamsRL)
        \item etiquetado-paso-param-aux(no\_paramFL(), no\_paramsRL()): 
            \subitem noop
        \item etiquetado-paso-param-aux(muchos\_paramsF(ParamsFL, Param), muchos\_paramsR(ParamsRL, Exp)): 
            \subitem etiquetado-paso-param-aux(ParamsFL, ParamsRL)
            \subitem etq =+ 3
            \subitem etiquetado(Exp)
            \subitem if Param = param\_ref(T,id) then
                \subsubitem etq++
            \subitem else
                \subsubitem if !es-designador(Exp) then
                    \subsubitem \hspace{2em} if ref!(Exp.tipo) == tipo\_int \&\& ref!(Param.tipo) == tipo\_real then
                        \subsubitem \hspace{4em} etq++
                    \subsubitem \hspace{2em} end if
                    \subsubitem \hspace{2em} etq++
                \subsubitem else
                    \subsubitem \hspace{2em} if ref!(Exp.tipo) == tipo\_int \&\& ref!(Param.tipo) == tipo\_real then
                        \subsubitem \hspace{4em} etq += 3
                    \subsubitem \hspace{2em} else
                        \subsubitem \hspace{4em} etq++
                    \subsubitem \hspace{2em} end if
                \subsubitem end if
            \subitem end if
        \item etiquetado-paso-param-aux(un\_paramF(Param), un\_paramsR(Exp)): 
            \subitem etq =+ 3
            \subitem etiquetado(Exp)
            \subitem if Param = param\_ref(T,id) then
                \subsubitem etq++
            \subitem else
                \subsubitem if !es-designador(Exp) then
                    \subsubitem \hspace{2em} if ref!(Exp.tipo) == tipo\_int \&\& ref!(Param.tipo) == tipo\_real then
                        \subsubitem \hspace{4em} etq++
                    \subsubitem \hspace{2em} end if
                    \subsubitem \hspace{2em} etq++
                \subsubitem else
                    \subsubitem \hspace{2em} if ref!(Exp.tipo) == tipo\_int \&\& ref!(Param.tipo) == tipo\_real then
                        \subsubitem \hspace{4em} etq += 3
                    \subsubitem \hspace{2em} end if
                    \subsubitem \hspace{2em} etq++
                \subsubitem end if
            \subitem end if
        \item recolecta\_subs(si\_decs(DecsAux)): 
            \subitem recolecta\_subs(DecsAux)
        \item recolecta\_subs(no\_decs()): 
            \subitem noop
        \item recolecta\_subs(muchas\_decs(DecsAux, Dec)): 
            \subitem recolecta\_subs(DecsAux)
            \subitem recolecta\_subs(Dec)
        \item recolecta\_subs(una\_dec(Dec)): 
            \subitem recolecta\_subs(Dec)
        \item recolecta\_subs(dec\_var(T, string)): 
            \subitem noop
        \item recolecta\_subs(dec\_tipo(T, string)): 
            \subitem noop
        \item recolecta\_subs(dec\_proc(string, ParamsF, Bloq)): 
            \subitem apila(sub\_pendientes, \$)
    \end{itemize} 

    \section{Especificación del proceso de generación de código}
        \begin{itemize}
            \item var sub\_pendientes = pila-vacia()
            \item gen-cod(prog(Bloq)): 
                \subitem gen-cod(Bloq)
                \subitem emit stop()
                \subitem while !es-vacia(sub\_pendientes)
                    \subsubitem sub = cima(sub\_pendientes)
                    \subsubitem desapila\_ind(sub\_pendientes)
                    \subsubitem let sub = dec\_proc(string,ParamsFL,Bloq) in
                        \subsubitem \hspace{2em} emit desapilad(sub.nivel)
                        \subsubitem \hspace{2em} gen-cod(Bloq)
                        \subsubitem \hspace{2em} emit desactiva(sub.nivel,sub.tam)
                        \subsubitem \hspace{2em} emit ir-ind()
                    \subsubitem end let
                \subitem end while
            \item gen-cod(bloq(Decs, Insts)): 
                \subitem recolecta\_subs(Decs)
                \subitem gen-cod(Insts)
            \item gen-cod(si\_instr(InstAux)): 
                \subitem gen-cod(InstAux)
            \item gen-cod(no\_instr()): 
                \subitem noop
            \item gen-cod(muchas\_instr(InstsAux, Inst)): 
                \subitem gen-cod(InstsAux)
                \subitem gen-cod(Inst)
            \item gen-cod(una\_instr(Inst)): 
                \subitem gen-cod(Inst)
            \item gen-cod(instr\_expr(Exp)): 
                \subitem gen-cod(Exp)
                \subitem emit desapila\_ind()
            \item gen-cod(instr\_if(Exp, Bloq)): 
                \subitem gen-cod(Exp)
                \subitem gen-acc-val(Exp)
                \subitem emit ir-f(\$.sig)
                \subitem gen-cod(Bloq)
            \item gen-cod(instr\_if\_else(Exp, Bloq1, Bloq2)): 
                \subitem gen-cod(Exp)
                \subitem gen-acc-val(Exp)
                \subitem emit ir-f(Bloq2.prim)
                \subitem gen-cod(Bloq1)
                \subitem emit ir-a(\$.sig)
                \subitem gen-cod(Bloq2)
            \item gen-cod(instr\_while(Exp, Bloq)): 
                \subitem gen-cod(Exp)
                \subitem gen-acc-val(Exp)
                \subitem emit ir-f(\$.sig)
                \subitem gen-cod(Bloq)
                \subitem emit ir-a(\$.prim)
            \item gen-cod(instr\_read(Exp)): 
                \subitem gen-cod(Exp)
                \subitem emit read()
                \subitem emit desapila-ind()
            \item gen-cod(instr\_write(Exp)): 
                \subitem gen-cod(Exp)
                \subitem gen-acc-val(Exp)
                \subitem emit write()
            \item gen-cod(instr\_nl()): 
                \subitem emit nl()
            \item gen-cod(instr\_new(Exp)): 
                \subitem gen-cod(Exp)
                \subitem let ref!(Exp.tipo) == tipo\_puntero(T) in
                    \subsubitem emit alloc(T.tam)
                \subitem end let
                \subitem emit desapila-ind()
            \item gen-cod(instr\_del(Exp)): 
                \subitem gen-cod(Exp)
                \subitem emit apila-ind()
                \subitem let ref!(E.tipo) == tipo\_puntero(T) in
                    \subsubitem emit dealloc(T.tam)
                \subitem end let
            \item gen-cod(instr\_call(string, ParamsR)): 
                \subitem emit activa(\$.vinculo.nivel,\$.vinculo.tam,\$.sig)
                \subitem gen-paso-param(\$.vinculo,ParamsR)
                \subitem emit ir-a(\$.vinculo.prim)
            \item gen-cod(instr\_bloque(Bloq)): 
                \subitem gen-cod(Bloq)
            \item gen-cod(si\_paramsR(ParamsRL)): 
                \subitem gen-cod(ParamsRL)
            \item gen-cod(no\_paramsR()): 
                \subitem noop 
            \item gen-cod(muchos\_paramsR(ParamsRL, Exp)): 
                \subitem gen-cod(ParamsRL)
                \subitem gen-cod(Exp)
            \item gen-cod(un\_paramsR(Exp)): 
                \subitem gen-cod(Exp)
            \item gen-cod(asig(Exp1, Exp2)): 
                \subitem gen-cod(Exp1)
                \subitem gen-cod(Exp2)
                \subitem if ref!(Exp1.tipo) == tipo\_real \&\& ref!(Exp2.tipo) == tipo\_int
                    \subsubitem gen-asig-prom(Exp2)
                \subitem else
                    \subsubitem gen-asig(Exp2)
                \subitem end if
            \item gen-asig(Exp): 
                \subitem if es-designador(Exp) then
                    \subsubitem emit copia(Exp.tipo.tam)
                \subitem else
                    \subsubitem emit desapila-ind()
                \subsubitem end if
            \item gen-asig-prom(Exp): 
                \subitem if es-designador(Exp) then
                    \subsubitem emit apila-ind()
                    \subsubitem emit int2real()
                    \subsubitem emit desapila-ind()
                \subitem else
                    \subsubitem emit int2real()
                    \subsubitem emit desapila-ind()
                \subitem end if
            \item gen-cod(menor(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit menor()
            \item gen-cod(mayor(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit mayor()
            \item gen-cod(menor\_igual(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit menor\_igual()
            \item gen-cod(mayor\_igual(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit mayor\_igual()
            \item gen-cod(igual(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit igual()
            \item gen-cod(no\_igual(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit no\_igual()
            \item gen-cod(suma(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit suma()
            \item gen-cod(resta(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit resta()
            \item gen-cod(and(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit and()
            \item gen-cod(or(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit or()
            \item gen-cod(mult(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit mult()
            \item gen-cod(div(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit div()
            \item gen-cod(mod(Exp1, Exp2)): 
                \subitem gen-cod-opnds(Exp1, Exp2)
                \subitem emit mod()
            \item gen-cod(negativo(Exp)): 
                \subitem gen-cod(Exp)
                \subitem gen-acc-val(Exp)
                \subitem emit negativo()
            \item gen-cod(not(Exp)): 
                \subitem gen-cod(Exp)
                \subitem gen-acc-val(Exp)
                \subitem emit not()
            \item gen-cod(index(Exp1, Exp2)): 
                \subitem gen-cod(Exp1)
                \subitem gen-cod(Exp2)
                \subitem gen-acc-val(Exp2)
                \subitem let ref!(Exp2.tipo) = tipo\_array(T,string) in
                    \subsubitem emit apila-int(T.tam)
                \subitem end let
                \subitem emit mul()
                \subitem emit suma()
            \item gen-cod(acceso(Exp, string)): 
                \subitem gen-cod(Exp)
                \subitem let ref!(Exp.tipo) = struct(Cs) in
                    \subsubitem emit apila-int(desplazamiento(Cs,string))
                \subitem end let
                \subitem emit suma()
            \item gen-cod(indireccion(Exp)): 
                \subitem gen-cod(Exp)
                \subitem emit apila-ind()
            \item gen-cod(lit\_ent(string)): 
                \subitem emit apila-int(string)
            \item gen-cod(lit\_real(string)): 
                \subitem emit apila-real(string)
            \item gen-cod(true()): 
                \subitem emit apila-bool(True)
            \item gen-cod(false()): 
                \subitem emit apila-bool(False)
            \item gen-cod(lit\_cadena(string)): 
                \subitem emit apila-string(string)
            \item gen-cod(iden(string)): 
                \subitem if \$.vinculo == dec\_var then 
                    \subsubitem gen-acc-id(\$.vinculo)
                \subitem else if \$.vinculo == param then 
                    \subsubitem gen-acc-id(\$.vinculo)
                \subitem else if \$.vinculo == param\_ref then 
                    \subsubitem gen-acc-id(\$.vinculo)
                \subitem end if
            \item gen-cod(null()): 
                \subitem emit apila-null()
            \item gen-cod-opnds(Opnd0,Opnd1): 
                \subitem if ref!(Opnd0.tipo) == tipo\_int \&\& ref!(Opnd1.tipo) == tipo\_real then
                    \subsubitem gen-cod(Opnd0)
                    \subsubitem gen-acc-val(Opnd0)
                    \subsubitem emit int2real()
                    \subsubitem gen-cod(Opnd1)
                    \subsubitem gen-acc-val(Opnd1)
                \subitem else if ref!(Opnd0.tipo) == tipo\_real \&\& ref!(Opnd1.tipo) == tipo\_int then
                    \subsubitem gen-cod(Opnd0)
                    \subsubitem gen-acc-val(Opnd0)
                    \subsubitem gen-cod(Opnd1)
                    \subsubitem gen-acc-val(Opnd1)
                    \subsubitem emit int2real()
                \subitem else
                    \subsubitem gen-cod(Opnd0)
                    \subsubitem gen-acc-val(Opnd0)
                    \subsubitem gen-cod(Opnd1)
                    \subsubitem gen-acc-val(Opnd1)
                \subitem end if
            \item gen-acc-val(Exp): 
                \subitem if es-designador(Exp) then
                    \subsubitem emit apila-ind()
                \subitem end if
            \item gen-acc-id(dec\_var(T,string)): 
                \subitem if \$.nivel = 0 then
                    \subsubitem emit apila-int(\$.dir)
                \subitem else
                    \subsubitem gen-acc-var(\$)
                \subitem end if
            \item gen-acc-id(param\_ref(T,string)): 
                \subitem gen-acc-var(\$)
                \subitem emit apila-ind()
            \item gen-acc-id(param(T,id)): 
                \subitem gen-acc-var(\$)
            \item gen-acc-var(V): 
                \subitem emit apilad(V.nivel)
                \subitem emit apila-int(V.dir)
                \subitem emit suma()
            \item recolecta\_subs(si\_decs(DecsAux)): 
                \subitem recolecta\_subs(DecsAux)
            \item recolecta\_subs(no\_decs()): 
                \subitem noop
            \item recolecta\_subs(muchas\_decs(DecsAux, Dec)): 
                \subitem recolecta\_subs(DecsAux)
                \subitem recolecta\_subs(Dec)
            \item recolecta\_subs(una\_dec(Dec)): 
                \subitem recolecta\_subs(Dec)
            \item recolecta\_subs(dec\_var(T, string)): 
                \subitem noop
            \item recolecta\_subs(dec\_tipo(T, string)): 
                \subitem noop
            \item recolecta\_subs(dec\_proc(string, ParamsF, Bloq)): 
                \subitem apila(sub\_pendientes, \$)
            \item gen-paso-param(dec\_proc(string,ParamsF,Bloq),ParamsR): 
                \subitem gen-paso-param-aux(ParamsF, ParamsR)
            \item gen-paso-param-aux(si\_paramF(ParamsFL), si\_paramsR(ParamsRL)): 
                \subitem gen-paso-param-aux(ParamsFL, ParamsRL)
            \item gen-paso-param-aux(no\_paramFL(), no\_paramsRL()): 
                \subitem noop
            \item gen-paso-param-aux(muchos\_paramsF(ParamsFL, Param), muchos\_paramsR(ParamsRL, Exp)): 
                \subitem gen-paso-param-aux(ParamsFL, ParamsRL)
                \subitem emit dup()
                \subitem emit apila-int(Param.dir)
                \subitem emit suma()
                \subitem gen-cod(Exp)
                \subitem if Param = param\_ref(T,id) then
                    \subsubitem emit desapila-ind()
                \subitem else if !es-designador(Exp) then
                    \subsubitem if ref!(Exp.tipo) == tipo\_int \&\& ref!(Param.tipo) == tipo\_real then
                        \subsubitem \hspace{2em} emit int2real()
                    \subsubitem emit desapila-ind()
                    \subsubitem else
                        \subsubitem \hspace{2em} if ref!(Exp.tipo) == tipo\_int \&\& ref!(Param.tipo) == tipo\_real then
                            \subsubitem \hspace{4em} emit apila-ind()
                            \subsubitem \hspace{4em} emit int2real()
                            \subsubitem \hspace{4em} emit desapila-ind()
                        \subsubitem \hspace{2em} else
                            \subsubitem \hspace{4em} emit copia(T.tam)
                        \subsubitem \hspace{2em} end if
                    \subsubitem end if
                \subitem end if
            \item gen-paso-param-aux(un\_paramF(Param), un\_paramsR(Exp)): 
                \subitem emit dup()
                \subitem emit apila-int(Param.dir)
                \subitem emit suma()
                \subitem gen-cod(Exp)
                \subitem if Param = param\_ref(T,id) then
                    \subsubitem \hspace{2em} emit desapila-ind()
                \subitem else if !es-designador(Exp) then
                    \subsubitem \hspace{2em} if ref!(Exp.tipo) == tipo\_int \&\& ref!(Param.tipo) == tipo\_real then
                        \subsubitem \hspace{4em} emit int2real()
                    \subsubitem \hspace{2em} emit desapila-ind()
                    \subsubitem \hspace{2em} else
                    \subsubitem \hspace{4em} if ref!(Exp.tipo) == tipo\_int \&\& ref!(Param.tipo) == tipo\_real then
                        \subsubitem \hspace{6em} emit apila-ind()
                        \subsubitem \hspace{6em} emit int2real()
                        \subsubitem \hspace{6em} emit desapila-ind()
                    \subsubitem \hspace{4em} else
                        \subsubitem \hspace{6em} emit copia(T.tam)
                    \subsubitem \hspace{4em} end if
                    \subsubitem \hspace{2em} end if
                \subitem end if
        \end{itemize} 
\end{document}